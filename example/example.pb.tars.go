// Code generated by protoc-gen-tars. DO NOT EDIT.
// source: example/example.proto

package example

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

import (
	context "context"
	tars "github.com/TarsCloud/TarsGo/tars"
	model "github.com/TarsCloud/TarsGo/tars/model"
	requestf "github.com/TarsCloud/TarsGo/tars/protocol/res/requestf"
	current "github.com/TarsCloud/TarsGo/tars/util/current"
	tools "github.com/TarsCloud/TarsGo/tars/util/tools"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// This following code was generated by tars
// Gernerated from example/example.proto
type Greeter struct {
	s model.Servant
}

//SetServant is required by the servant interface.
func (obj *Greeter) SetServant(s model.Servant) {
	obj.s = s
}

//AddServant is required by the servant interface
func (obj *Greeter) AddServant(imp impGreeter, objStr string) {
	tars.AddServant(obj, imp, objStr)
}

////AddServant adds servant  for the service with context
func (obj *Greeter) AddServantWithContext(imp impGreeterWithContext, objStr string) {
	tars.AddServantWithContext(obj, imp, objStr)
}

//TarsSetTimeout is required by the servant interface. t is the timeout in ms.
func (obj *Greeter) TarsSetTimeout(t int) {
	obj.s.TarsSetTimeout(t)
}

//TarsSetProtocol is required by the servant interface. t is the protocol.
func (obj *Greeter) TarsSetProtocol(p model.Protocol) {
	obj.s.TarsSetProtocol(p)
}

type impGreeter interface {
	Hello(input Request) (output Response, err error)
}

type impGreeterWithContext interface {
	Hello(ctx context.Context, input Request) (output Response, err error)
}

//Dispatch is used to call the user implement of the defined method.
func (obj *Greeter) Dispatch(ctx context.Context, val interface{}, req *requestf.RequestPacket, resp *requestf.ResponsePacket, withContext bool) (err error) {
	input := tools.Int8ToByte(req.SBuffer)
	var output []byte
	funcName := req.SFuncName
	switch funcName {

	case "Hello":
		inputDefine := Request{}
		if err = proto.Unmarshal(input, &inputDefine); err != nil {
			return err
		}
		var res Response
		if withContext == false {
			imp := val.(impGreeter)
			res, err = imp.Hello(inputDefine)
			if err != nil {
				return err
			}
		} else {
			imp := val.(impGreeterWithContext)
			res, err = imp.Hello(ctx, inputDefine)
			if err != nil {
				return err
			}
		}
		output, err = proto.Marshal(&res)
		if err != nil {
			return err
		}

	default:
		return fmt.Errorf("func mismatch")
	}
	var _status map[string]string
	s, ok := current.GetResponseStatus(ctx)
	if ok && s != nil {
		_status = s
	}
	var _context map[string]string
	c, ok := current.GetResponseContext(ctx)
	if ok && c != nil {
		_context = c
	}
	*resp = requestf.ResponsePacket{
		IVersion:     1,
		CPacketType:  0,
		IRequestId:   req.IRequestId,
		IMessageType: 0,
		IRet:         0,
		SBuffer:      tools.ByteToInt8(output),
		Status:       _status,
		SResultDesc:  "",
		Context:      _context,
	}
	return nil
}

// Hello is client rpc method as defined
func (obj *Greeter) Hello(input Request, _opt ...map[string]string) (output Response, err error) {
	ctx := context.Background()
	return obj.HelloWithContext(ctx, input, _opt...)
}

// HelloWithContext is client rpc method as defined
func (obj *Greeter) HelloWithContext(ctx context.Context, input Request, _opt ...map[string]string) (output Response, err error) {
	var inputMarshal []byte
	inputMarshal, err = proto.Marshal(&input)
	if err != nil {
		return output, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}

	resp := new(requestf.ResponsePacket)

	err = obj.s.Tars_invoke(ctx, 0, "Hello", inputMarshal, _status, _context, resp)
	if err != nil {
		return output, err
	}
	if err = proto.Unmarshal(tools.Int8ToByte(resp.SBuffer), &output); err != nil {
		return output, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range resp.Status {
			_status[k] = v
		}
	}

	return output, nil
}
