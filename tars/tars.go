package tars

import (
	"fmt"
	"path"
	"strconv"
	"strings"

	"github.com/go-tars/protoc-gen-tars/generator"
	pb "github.com/golang/protobuf/protoc-gen-go/descriptor"
)

// Paths for packages used by code generated in this file,
// relative to the import_prefix of the generator.Generator.
const (
	contextPkgPath = "context"
	modelPkgPath   = "github.com/TarsCloud/TarsGo/tars/model"
	requestPkgPath = "github.com/TarsCloud/TarsGo/tars/protocol/res/requestf"
	tarsPkgPath    = "github.com/TarsCloud/TarsGo/tars"
	toolsPath      = "github.com/TarsCloud/TarsGo/tars/util/tools"
	currentPath    = "github.com/TarsCloud/TarsGo/tars/util/current"
)

var (
	contextPkg string
	modelPkg   string
	requestPkg string
	tarsPkg    string
	tools      string
	current    string
)

func init() {
	generator.RegisterPlugin(new(tars))

	contextPkg = generator.RegisterUniquePackageName("context", nil)
	modelPkg = generator.RegisterUniquePackageName("model", nil)
	requestPkg = generator.RegisterUniquePackageName("requestf", nil)
	tarsPkg = generator.RegisterUniquePackageName("tars", nil)
	tools = generator.RegisterUniquePackageName("tools", nil)
	current = generator.RegisterUniquePackageName("current", nil)
}

// tars is an implementation of the Go protocol buffer compiler's
// plugin architecture.  It generates bindings for tars rpc support.
type tars struct {
	gen *generator.Generator
}

//Name returns the name of this plugin
func (t *tars) Name() string {
	return "tars"
}

//Init initializes the plugin.
func (t *tars) Init(gen *generator.Generator) {
	t.gen = gen
}

// upperFirstLatter make the fisrt charater of given string  upper class
func upperFirstLatter(s string) string {
	if len(s) == 0 {
		return ""
	}
	if len(s) == 1 {
		return strings.ToUpper(string(s[0]))
	}
	return strings.ToUpper(string(s[0])) + s[1:]
}

// Given a type name defined in a .proto, return its object.
// Also record that we're using it, to guarantee the associated import.
func (t *tars) objectNamed(name string) generator.Object {
	t.gen.RecordTypeUse(name)
	return t.gen.ObjectNamed(name)
}

// Given a type name defined in a .proto, return its name as we will print it.
func (t *tars) typeName(str string) string {
	return t.gen.TypeName(t.objectNamed(str))
}

// GenerateImports generates the import declaration for this file.
func (t *tars) GenerateImports(file *generator.FileDescriptor, imports map[generator.GoImportPath]generator.GoPackageName) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}

	t.P("import (")
	t.P(contextPkg, " ", strconv.Quote(path.Join(t.gen.ImportPrefix, contextPkgPath)))
	t.P(modelPkg, " ", strconv.Quote(path.Join(t.gen.ImportPrefix, modelPkgPath)))
	t.P(requestPkg, " ", strconv.Quote(path.Join(t.gen.ImportPrefix, requestPkgPath)))
	t.P(tarsPkg, " ", strconv.Quote(path.Join(t.gen.ImportPrefix, tarsPkgPath)))
	t.P(tools, " ", strconv.Quote(path.Join(t.gen.ImportPrefix, toolsPath)))
	t.P(current, " ", strconv.Quote(path.Join(t.gen.ImportPrefix, currentPath)))
	t.P(")")
	t.P()
}

// P forwards to g.gen.P.
func (t *tars) P(args ...interface{}) { t.gen.P(args...) }

// Generate generates code for the services in the given file.
func (t *tars) Generate(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}
	for i, service := range file.FileDescriptorProto.Service {
		t.generateService(file, service, i)
	}
}

// generateService generates all the code for the named service
func (t *tars) generateService(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto, index int) {
	originServiceName := service.GetName()
	serviceName := upperFirstLatter(originServiceName)
	t.P("// This following code was generated by tars")
	t.P(fmt.Sprintf("// Gernerated from %s", file.GetName()))
	t.P(fmt.Sprintf(`type  %s struct {
		s model.Servant
	}
	`, serviceName))
	t.P()

	//generate SetServant
	t.P(fmt.Sprintf(`//SetServant is required by the servant interface.
	func (obj *%s) SetServant(s model.Servant){
		obj.s = s
	}
	`, serviceName))
	t.P()
	//generate AddServant
	t.P(fmt.Sprintf(`//AddServant is required by the servant interface
	func (obj *%s) AddServant(imp imp%s, objStr string){
		tars.AddServant(obj, imp, objStr)
	}`, serviceName, serviceName))

	//generate AddServantWithContext
	t.P(fmt.Sprintf(`////AddServant adds servant  for the service with context
	func (obj *%s) AddServantWithContext(imp imp%sWithContext, objStr string) {
		tars.AddServantWithContext(obj, imp, objStr)
	}`, serviceName, serviceName))
	t.P()

	//generate TarsSetTimeout
	t.P(fmt.Sprintf(`//TarsSetTimeout is required by the servant interface. t is the timeout in ms. 
	func (obj *%s) TarsSetTimeout(t int){
		obj.s.TarsSetTimeout(t)
	}
	`, serviceName))
	t.P()

	//generate TarsSetProtocol
	t.P(fmt.Sprintf(`//TarsSetProtocol is required by the servant interface. t is the protocol. 
	func (obj *%s) TarsSetProtocol(p model.Protocol){
		obj.s.TarsSetProtocol(p)
	}
	`, serviceName))
	t.P()

	//generate the interface
	t.P(fmt.Sprintf("type imp%s interface{", serviceName))
	for _, method := range service.Method {
		t.P(fmt.Sprintf("%s (input %s) (output %s, err error)",
			upperFirstLatter(method.GetName()), t.typeName(method.GetInputType()), t.typeName(method.GetOutputType())))
	}
	t.P("}")
	t.P()

	//generate the context interface
	t.P(fmt.Sprintf("type imp%sWithContext interface{", serviceName))
	for _, method := range service.Method {
		t.P(fmt.Sprintf("%s (ctx context.Context, input %s) (output %s, err error)",
			upperFirstLatter(method.GetName()), t.typeName(method.GetInputType()), t.typeName(method.GetOutputType())))
	}
	t.P("}")
	t.P()

	//gernerate the dispathcer
	t.generateDispatch(service)

	for _, method := range service.Method {
		t.generateClientCode(service, method)
	}
}
func (t *tars) generateClientCode(service *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto) {
	methodName := upperFirstLatter(method.GetName())
	serviceName := upperFirstLatter(service.GetName())
	inType := t.typeName(method.GetInputType())
	outType := t.typeName(method.GetOutputType())
	t.P(fmt.Sprintf(`// %s is client rpc method as defined
		func (obj *%s) %s(input %s, _opt ...map[string]string)(output %s, err error){
			ctx := context.Background()
			return obj.%sWithContext(ctx, input, _opt...)
		}
	`, methodName, serviceName, methodName, inType, outType, methodName))

	t.P(fmt.Sprintf(`// %sWithContext is client rpc method as defined
		func (obj *%s) %sWithContext(ctx context.Context, input %s, _opt ...map[string]string)(output %s, err error){
			var inputMarshal []byte
			inputMarshal, err = proto.Marshal(&input)
			if err != nil {
				return output, err
			}

			var _status map[string]string
			var _context map[string]string
			if len(_opt) == 1 {
				_context = _opt[0]
			} else if len(_opt) == 2 {
				_context = _opt[0]
				_status = _opt[1]
			}

			resp := new(requestf.ResponsePacket)

			err = obj.s.Tars_invoke(ctx, 0, "%s", inputMarshal, _status, _context, resp)
			if err != nil {
				return output, err
			}
			if err = proto.Unmarshal(tools.Int8ToByte(resp.SBuffer), &output); err != nil{
				return output, err
			}

			if len(_opt) == 1 {
				for k := range _context {
					delete(_context, k)
				}
				for k, v := range resp.Context {
					_context[k] = v
				}
			} else if len(_opt) == 2 {
				for k := range _context {
					delete(_context, k)
				}
				for k, v := range resp.Context {
					_context[k] = v
				}
				for k := range _status {
					delete(_status, k)
				}
				for k, v := range resp.Status {
					_status[k] = v
				}
			}

			return output, nil
		}
	`, methodName, serviceName, methodName, inType, outType, method.GetName()))
}
func (t *tars) generateDispatch(service *pb.ServiceDescriptorProto) {
	serviceName := upperFirstLatter(service.GetName())
	t.P(fmt.Sprintf(`//Dispatch is used to call the user implement of the defined method.
	func (obj *%s) Dispatch(ctx context.Context, val interface{}, req * requestf.RequestPacket, resp *requestf.ResponsePacket, withContext bool)(err error){
		input := tools.Int8ToByte(req.SBuffer)
		var output []byte
		funcName := req.SFuncName
		switch funcName {
	`, serviceName))
	for _, method := range service.Method {
		t.P(fmt.Sprintf(`case "%s":
			inputDefine := %s{}
			if err = proto.Unmarshal(input,&inputDefine); err != nil{
				return err
			}
			var res %s
            if withContext == false {
				imp := val.(imp%s)
				res, err = imp.%s(inputDefine)
				if err != nil {
					return err
				}
			}else {
				imp := val.(imp%sWithContext)
				res, err = imp.%s(ctx, inputDefine)
				if err != nil {
					return err
				}
			}
			output , err = proto.Marshal(&res)
			if err != nil {
				return err
			}
		`, method.GetName(), t.typeName(method.GetInputType()), t.typeName(method.GetOutputType()), serviceName, upperFirstLatter(method.GetName()), serviceName, upperFirstLatter(method.GetName())))
	}
	t.P(`default:
			return fmt.Errorf("func mismatch")
	}
	var _status map[string]string
	s, ok := current.GetResponseStatus(ctx)
	if ok && s != nil {
		_status = s
	}
	var _context map[string]string
	c, ok := current.GetResponseContext(ctx)
	if ok && c != nil {
		_context = c
	}
	*resp = requestf.ResponsePacket{
		IVersion:     1,
		CPacketType:  0,
		IRequestId:   req.IRequestId,
		IMessageType: 0,
		IRet:         0,
		SBuffer:      tools.ByteToInt8(output),
		Status:       _status,
		SResultDesc:  "",
		Context:      _context,
	}
	return nil
}
	`)
	t.P()
}
